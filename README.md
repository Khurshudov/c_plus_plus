1. [Задача сортировки массива. Пример алгоритма, решающего эту задачу за O(N log(N)). Доказательство факта, что любой алгоритм сортировки в среднем тратит время не меньшее θ(N log(N)). Алгоритм Quick Sort, его сложность и оптимизации. ](./01_sort/README.md)
2. [Алгоритм Heap Sort: описание лежащих в основе структур данных, доказательство оценки сложности.](./02_heapSort/README.md)
3. Структура данных хеш-таблица: определение, интерфейс, сложность выполнения основных операций. Способы разрешения конфликтов. Пример реализации функции добавления нового элемента для открытой адресации.
4. Структура данных красно-чёрное дерево. Что такое сбалансированность дерева и как её можно достигнуть. Сбалансированность красно-чёрных деревьев. Оценки времени поиска, добавления и удаления элементов. Пример реализации добавления элементов,
включая вращения.
5. Структура данных двоичный контейнер (Range Minimum Query, RMQ): описание и
примеры применения. Алгоритм построения двоичного контейнера, алгоритм выполнения запроса "минимальный элемент в промежутке [i, j)", алгоритм выполнения запроса "10 минимальных элементов в промежутке [i, j)". Решение задачи RMQ с помощью таблицы.
6. Задача о наименьшем общем предке (Least Common Ancestor, LCA). Сведение к задаче RMQ. Сведение RMQ к LCA.
7. Жадные алгоритмы. Пример жадного алгоритма с оценкой качества получаемого решения.
8. Динамическое программирование. Общий метод и пример применения с оценкой сложности.
9. Дискретная и непрерывная задачи о рюкзаке.
10. Задача о наибольшей общей подпоследовательности (Longest Common Subsequence,
LCS). Расстояние Левенштейна.
11. Алгоритмы обхода графа в глубину и в ширину.
12. Система непересекающихся множеств. Алгоритм Крускала.
13. Алгоритмы Флойда и Дейкстры для поиска кратчайших путей в графе.
14. Кучи. Бинарная, биномиальная, фибоначчиева. Алгоритмы для работы с кучей в STL. Очередь с приоритетами и реализация в STL.
15. Поиск подстроки в тексте. Поиск общей подстроки максимальной длины двух текстов. Суффиксное дерево. Построение за линейное время.
16. Суффиксный массив. Построение за O(N log N). Линейный алгоритм.
17. Инфиксная и постфиксная формы записи выражений. Перевод из одной системы в
другую.
18. Средства объектно-ориентированного программирования в C++.
19. Шаблоны в C++.
20. Основные классы-контейнеры и алгоритмы стандартной библиотеки STL.
21. Обработка исключений в С++.
22. Представление целых чисел(знаковых/беззнаковых) в памяти
компьютера. Представление вещественных чисел.
23. Логическая архитектура компьютера: фон Неймана, гарвардская.
24. Средства распараллеливания/ускорения работы процессора: конвейер, кэш,
суперскалярная архитектура.
25. Задачи операционной системы: понятие вычислительной системы, управление
физическими/логическими ресурсами, планирование. Типы операционных систем: пакетные, разделения времени, реального времени, сетевые.
26. Понятие процесса, виды процессов.
27. Файловые системы: FAT, NTFS, UFS, FFS. Сравнение.
28. Управление памятью: одиночное распределение, cтраничное, сегментное,
сегментностраничное, свопинг
29. Взаимодействие процессов, IPC: пайпы, сигналы, очереди сообщений, сокеты,
семафоры, разделяемая память.
30. Сеть: Уровни ISO/OSI, TCP/IP, Передача данных. Системные вызовы для поддержки сети в ОС (socket,bind,listen,access,connect,read,write,send,recv...).
31. Базы данных. Классификация БД по модели данных. Реляционная теория. Атрибуты, кортежи, домены, отношения. Первичные и внешние ключи.
32. Проектирование БД. Функциональные зависимости. Нормальные формы. Декомпозиция.
33. Реляционные операции. Агрегаты, группировки, аналитические функции.
34. Физическое устройство БД. Страницы данных. Индексы.
35. Транзакции, ACID. Атомарность и долговечность. ARIES, логирование.
36. Конкурентный доступ. Согласованность и изолированность. Виды изоляции.
37. Определение функционального программирования. Абстракция и декомпозиция при
функциональном подходе. Декларативное программирование. Плюсы и минусы.
38. Лямбда-исчисление. Редукция. Функции нескольких аргументов. Каррирование.
39. Виды рекурсии. Рекурсивные структуры данных. Функциональные структуры данных.
40. Нормальный и аппликативный порядок редукции. Ленивые и энергичные вычисления. Механизмы вызова и проблема разделения. Теорема Чёрча-Россера и теорема
стандартизации. Экстенсиональность. Слабая заголовочная нормальная форма.
41. Средства объектно-ориентированного программирования в языке Java.
42. Виртуальная машина Java. Управление памятью. Передача примитивных типов в
функции. Передача ссылочных типов в функции. Проблема изменения ссылки внутри подпрограммы. Статические инициализаторы. Удаление неиспользуемых объектов и метод finalize. Проблема деструкторов для сложно устроенных объектов. Сборка мусора.
43. Сетевое программирование на Java. Сериализация/десериализация.
44. Коллекции и массивы в Java.
45. Моделирование при помощи UML. Статическое представление модели. Диаграммы
классов. Виды отношений: ассоциация, зависимость, абстракция, реализация и другие. Ограничения. Экземпляры классов. Варианты использования (прецеденты). Выделение классов. Метод Аббота, карточки Класс-Контракт-Коллеги (CRC), диаграммы устойчивости.
46. Динамическое представление модели. Поведение. Основные определения. Структурированный классификатор. Композит и часть. Диаграммы внутренней структуры. Представление взаимодействия. Диаграммы взаимодействия и коммуникации. Роль, спецификация выполнения, сообщение, кооперация. Описание сценариев вариантов использования. Представление деятельности. Представление о сетях Петри. Виды действий, разделы. Контекст выполнения. Потоки управления и данных (объектные). Представление процессов на диаграммах деятельности. Представление конечных автоматов. Диаграммы схем состояний. Состояние, переход, псевдосостояния, составные состояния. Семантика конечных автоматов в UML. Обработка событий, переход по завершении. Моделирование жизненного цикла классификатора с помощью конечных автоматов. Пакеты. Управление моделью.
47. Методы структурного проектирования. Виды методов: сверху-вниз, снизу-вверх, итеративные. Модульность. Принципы разделения системы на модули. Метрики качества модульной структуры. Метод постепенного уточнения, структурные диаграммы (STD). Диаграммы потоков данных (DFD). Метод структурного программирования Джексона (JSP).
48. Паттерны проектирования. Структурные, создания и паттерны поведения. Примеры паттернов. Строитель. Посетитель. Шаблон метода. Фасад. Мост. Метрики качества объектно-ориентированной структуры. Эвристики GRASP.
49. Приближение функций, заданных на дискретном множестве. Существование и единственность алгебраического интерполяционного полинома. Интерполяционный полином в форме Лагранжа и в форме Чебышева.
50. Численное интегрирование. Квадратурные формулы Ньютона-Котеса и оценка их погрешности. Квадратурные формулы Гаусса.
51. Решение СЛАУ. Обусловленность. Метод Гаусса, метод Гаусса с выбором главного элемента, метод прогонки. LU-разложение.
52. Итерационные методы решения СЛАУ. Метод простых итераций, необходимое, достаточное условия его сходимости.
53. Методы численного решения уравнений и систем нелинейных уравнений. Принцип сжимающих отображений. Метод простых итераций. Метод Ньютона.
54. Численные методы решения ОДУ. Методы Рунге-Кутты.
