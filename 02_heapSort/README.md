## Алгоритм Heap Sort: описание лежащих в основе структур данных, доказательство оценки сложности.

[Ссылка на код](./main.cpp)

1. Описание алгоритма
    1. Построить из нашего массива сортирующего дерева. **Сыновья <= отца.**
    ``` c++
    for (int i = (n+1)/2; i >= 0 ; --i) {
        heapify(arr, n, i);
    }

    // where heapify is

    void heapify(int *arr, int n, int idx) {
        int left = 2*idx + 1;
        int right = 2*idx + 2;

        int max = idx;

        if(left < n && arr[left] > arr[max]) {
            max = left;
        }

        if(right < n && arr[right] > arr[max]) {
            max = right;
        }

        if(max != idx){
            int tmp = arr[max];
            arr[max] = arr[idx];
            arr[idx] = tmp;
            heapify(arr, n, max);
        }
    }


    ```

    2. На первом шаге меняем __0__ элемент на __n-1__ и запускаем heapify с нулевого элемента до __n-1__-го. На втором шаге меняем __0__ элемент на __n-2__ и запускаем heapify с нулевого элемента до __n-2__-го.
    ``` c++
    for (int i = n-1; i > 0; i--){
        int tmp = arr[0];
        arr[0] = arr[i];
        arr[i] = tmp;
        heapify(arr, i, 0);
    }
    ```
2. Описание структур данных, лежащих в основе
    
    В основе лежит __сортирующее бинарное дерево__. __Сортирующее дерево__ - это такое дерево, у которого выполнены условия:
    1. Каждый лист имеет глубину либо __d__, либо __d-1__, где __d__ - глубина дерева.
    2. Значение в любой вершине не меньше(не больше) значения ее потомков.
    3. Нижний слой заполняется слева направо без дырок.

    Функциональность:
    * Добавить элемент в кучу. Сложность O(_log(n)_)
    * Исключить максимальный элемент из кучи. Время работы O(_log(n)_)
    * Изменить значение любого элемента. Время работы O(_log(n)_)
3. Доказательство оценки сложности

Построение из произвольного массива кучи имеет сложность _O(n)_. После того, как у нас простроена такая куча, мы можем взять ее нулевой элемент и поменять его с поледним. Тогда, будем счиать, что последний эдемент это часть отстортированного массива, но свойство кучи нарушилось. Вызовем функцию _heapify_, которая за _O(log n)_ восстанавливает свойство кучи. Таких вызовов у нас будет _n_. Соответсвенно, алгоритм имеет сложность _O(n * log(n))_.

Легко дать простую верхнюю оценку, построения из произвольного массива кучи, равную _O(n * log(n))_. Каждый вызов функции heapify имеет сложность _O(log(n))_, а таких вызовов _n_. Таким образом, время работы алгоритма равно _O(n * log(n))_. Эта верхняя оценка корректна и сохраняет общую сложность сортировки, равную _O(n * log(n))_, но можно доказать, что построение кучи происходит за _O(n)_. (КОРМЕН стр. 186).

Время работы процедуры heapify на поддереве размера _n_ с корнем в заданном узле _i_ вычисляется как время _O(1)_, необходимое для обмена значений, плюс время работы этой процедуры с поддеревом, корень которого находится в одном из дочерних узлов узла _i_. Размер каждого из таких дочерних поддеревьев не превышает величину 2n/3. Таким образом, время работы процедуры heapify описывается следующим рекуррентным соотношением: _T(n)=T(2n/3)+O(1)_. Решением этого рекурентного уравнения является _T(n)=O(log(n))_.