## Задача сортировки массива. Пример алгоритма, решающего эту задачу за O(N log(N)). Доказательство факта, что любой алгоритм сортировки в среднем тратит время не меньшее θ(N log(N)). Алгоритм Quick Sort, его сложность и оптимизации.

### Задача сортировки массива.
Задача сортировки заключается в упорядочивании произвольной входной последовательности. Вход: последовательность, состоящая из _n_ чисел. Выход: такая переставновка входной последовательности, что каждый последующий элемент меньше либо равен предшествующего.
### Пример алгоритма, решающего эту задачу за O(N log(N)).
Сортировка кучей или слиянием.
### Доказательство факта, что любой алгоритм сортировки в среднем тратит время не меньшее θ(N log(N)).
Рассмотрим модель __решающего дерева__. __Дерево решений__ — это полное бинарное дерево, в котором представлены операции сравнения элемен- тов, производящиеся тем или иным алгоритмом сортировки, который обрабатывает входные данные заданного размера. В вершинах дерева указаны эдементы которые сравниваются, в ветвях дерева указывается знак ">" или "<=".

Из приведенных выше рассуждений становится понтяно, что для доказательства теоремы достаточно определить высоту дерева, в котором каждая перестановка представлена достижимым листом. Рассмотрим дерево решений высотой _h_ с _l_ достижимыми листьями, которое соответствует сортировке сравнением _n_ элементов. Поскольку каждая из _n!_ перестановок входных элементов сопоставляется с одним из листьев, _n! <= 􏰃 l_. Так как бинарное дерево высоты _h_ имеет не более _2^h_ листьев, получаем: _n! <= l <= 2^h_, откуда после логарифмирования в силу монотонности логарифма _h >= lg(n!) = Ω(nlgn)_.
### Алгоритм Quick Sort, его сложность и оптимизации.
    
Входной массив разбивается на две части по опрному элементу так, что в левой части массива все элементы меньше опорного, в правой части массива все элементы больше, а посередине - сам опорный элемент. Для каждой части массива рекурсивно применяется быстрая сортировка.

#### Алгоритм разбиения(partiton)
```cpp
int partition(int *arr, int n) {
    int opor = arr[n-1];

    int right1 = 0;

    for (int i = 0; i < n - 1; ++i) {
        if (arr[i] >= opor){
            right1 += 1;
            if(right1 != 0) {
                int tmp = arr[right1 - 1];
                arr[right1 - 1] = arr[i];
                arr[i] = tmp;
            }
        }
    }

    int tmp = arr[right1];
    arr[right1] = arr[n-1];
    arr[n-1] = tmp;

    return right1;
}
```

#### Алгоритм сортировки
```cpp
void sort(int *arr, int l, int r){
    if (r - l <= 1) return;
    int right1 = partition(arr, l, r);
    cout << right1 << endl;
    sort(arr, l, right1);
    sort(arr, right1, r);
}
```

#### Сложность
Для выполнения разбиения(partition) требуется _O(n)_ операций. Рассмотрим наихудший вариант разбиаения, а именно в одном массиве остается _0_ эллемент, а в другом _n-1_. Запишем соответствующее рекуррентное уравнение _T(n) = T(n-1) + T(0) + O(n) = T(n-1) + O(n)_. Из этого уравнени понятно, что в худшем случае оценка равняется _O(n^2)_. 

Однако, в самом благоприятном случае, разбиаения произойдет на 2 массива одинакового размера. Запишем соответствующее рекуррентное уравнение _T(n) = 2T(n/2)+ O(n)_. Из этого уравнени понятно, что в худшем случае оценка равняется _O(n*log(n))_.

#### Оптимизация

1. Опорный объект выбирать выбор среднего элемента/случайно/медиана из первого, последнего, среднего.
2. При достижении определенной глубины переходить на другие методы сортировки.